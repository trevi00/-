## 해시
- 해시 함수 : 키 값을 원소의 위치로 변환하는 함수이다.
- 해시 테이블 : 키(key)와 값(value)의 쌍을 저장하는 데이터 구조로, 해시 함수에 의해 계산된 특정(slot) 또는 버킷(bucket)에 항목을 저장한 표이다.
- 해시검색 : 
	- 해시 테이블을 사용하여 데이터를 매우 빠르게 검색하는 방법이다.
	- 데이터 검색, 삽입, 삭제 작업이 평균적으로 O(1)의 시간 복잡도도 매우 효율적이다.
- 검색 방법 : 
	- 키 값에 대해서 해시 함수를 계산하여 주소를 구한다.
	- 구한 주소에 해당하는 해시 테이블로 바로 이동한다.
	- 해당 주소에 찾는 항목이 있으면 검색 성공, 없으면 검색 실패이다.
- 해싱 함수의 종류
	- 제산 함수
		- 함수는 나머지 연산자 mod(C에서의 %연산자)를 사용하는 방법이다.
		- 키 값 k를 해시 테이블의 크기 M으로 나눈 나머지를 해서 주소로 사용한다.
		- M으로 나눈 나머지 값은 0~(M-1)이 되므로 해시 테이블의 인덱스로 사용할 수 있다.
		- 해시 주소는 충돌 발생 없이 고르게 분포하도록 생성되어야 하므로, 키 값을 나누는 해시 테이블의 크기 M은 적당한 크기의 소수를 사용한다.
	- 이동 접지 함수
		- 키의 비트 수가 해시 테이블 인덱스의 비트 수보다 큰 경우에 주로 사용한다.
		- 각 분할 부분을 이동 시켜서 오른쪽 끝자리가 일치하도록 맞추고 더하는 방법이다.
	- 숫자 분석 함수
		- 키 값을 이루고 있는 각 자릿수의 분포를 분석하여 해시 주소로 사용한다.
		- 각 키 값을 적절히 선택한 진수로 변환한 후에 각 자릿수의 분포를 분석하여 가장 편중된 분산을 가진 자릿수는 생략하고, 가장 고르게 분포된 자릿수부터 해시 테이블 주소의 자릿수만큼 차례로 뽑아서 만든 수를 역순으로 바꾸어서 주소로 사용한다.
	- 진법 변환 함수
		- 키 값이 10진수가 아닌 다른 진수일 때, 10진수로 변환하고 해시 테이블 주소로 필요한 자릿수만큼만 하위 자리의 수를 사용하는 방법이다.
	- 폴딩법
		- 키를 여러 부분으로 나누고, 이 부분들을 조합하여 해시 값을 만드는 방법이다.
		- 조합할 때는 더하기, XOR 등 여러 방법을 사용할 수 있다.
		- 단순 폴딩(Simple Folding)법으로 "123456789"의 해시 값을 구하면 "1368"이다.
		- 경계 폴딩(Boundary Folding)법으로 "123456789"의 해시 값을 구하면 "1566"이다. 키를 3개의 부분으로 나눈 후 첫번째 부분은 그대로, 두번째 부분은 뒤집어서, 세번째 부분은 그대로 사용하여 계산했기 때문이다.


## 데이터 저장소 설계
### 중복 테이블을 추가하는 방법
- 집계 데이터 추가 : 활용하고자 하는 집계정보를 위한 테이블을 추가하고, 각 원본테이블에 트리거를 등록시켜 활용한다.
- 진행 테이블의 추가 : 이력 관리 등의 목적으로 사용되며 활용도가 좋아지도록 기본키를 적절히 설정한다.
- 특정 부분면을 포함하는 테이블 추가 : 큰 테이블의 특정 부분면을 사용하는 경우에는 자주 사용되는 부분으로 새로운 테이블을 생성하여 활용한다.

### 스키마
- 외부 스키마는 사용자 관점
- 내부 스키마는 저장장치 관점
- 개념 스키마는 조직전체 관점

### 파티션
>조합분할
>해시분할 
>범위분할
- 파티션 설계 : 대용량DB는 몇개의 중요한 트랜잭션 테이블에서 데이터가 증가하므로, 보다 작은 단위로 나누어 성능 저하를 방지하고 관리하기 쉽게 한다.
- 파티션 종류
	- 범위 분할 : 지정한 열의 값을 기준으로 분한
	- 해시 분할 : 해시 함수에 따라 분할
	- 조합 분할 : 범위분할 후, 해시 함수를 적용하여 다시 분할

## 단위 모듈 테스트
### Black Box
- 사용자 관점
1. 사용자 요구사항 명세를 보면서 테스트한다.
2. 구현된 기증을 테스트한다.
3. 해당 기능의 작동 여부를 테스트한다.
- 동등 분할 검사
- 경계값 분석
- 오류 예측
**테스트하기 쉽다**

### White Box
- 개발자 관점
1. 프로그램 내부 로직(수행경로 구조, 루프 등)을 보면서 테스트를 수행한다.
2. 소스코드의 논리적인 경로를 테스트한다.
- 기초 경로 검사
- 제어 구조 검사
**오류를 발견하기 쉽다.**

### 테스트 드라이버 (Test Driver)
테스트 대상이 되는 모듈의 상위 가상 모듈 (상향식)

### 테스트 스텁 (Test Stub)
테스트 대상이 되는 모듈의 하위 가상 모듈 (하향식)

## 저작권 보호 기술 (DRM)의 흐름
- 콘텐츠 제공자 : 영화 스튜디오, 뉴스 미디어 회사 등
- 콘텐츠 분배자 : 스트리밍 서비스 (넷플릭스), 케이블 TV 제공업체, 인터넷 서비스 제공업체
- 콘텐츠 소비자 : 시청자, 청취자, 독자
- 클리어링 하우스 : 디지털 저작권 관리 (DRM) 시스템, 결제 처리 회사 (PayPal, Visa)

### 저작권 보호 기술(DRM)의 구성 요소
- 콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자
- 콘텐츠 분배자 : 쇼핑몰 등으로써 암호화된 콘텐츠 제공
- 패키저 (Packager) : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
- 보안 컨테이너 : 원본을 안전하게 유통하기 위한 전자적 보안 장치
- DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제
- 클리어링 하우스 : 키 관리 및 라이선스 발급 관리

### 디지털 저작권 관리(DRM)의 기술 요소
- 암호화 (Encryption) : 
	- 콘텐츠 및 라이선스를 암호화하고, 전자 서명을 할 수 있는 기술
- 키 관리 (Key Management) : 
	- 콘텐츠를 암호화한 키에 저장, 배포, 회수, 파기 기술
- 암호화 파일 생성 (Packager) :
	- 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- 식별 기술 (Identification) : 
	- 객체의 위치와 상관없이 해당 객체를 고유하게 식별하는 "DOI", 웹 주소(URL)와 같은 리소스를 가리키기 위해 사용하는 "URI"등이 있다.

### 디지털 저작권 관리(DRM)의 기술 요소
- 저작권 표현 : 라이선스의 내용 표현 기술로 디지털 권리 및 라이선싱 정보를 표현하고 배포
- 정책 관리 : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- 크랙 방지 : 크랙에 의한 콘텐츠 사용 방지 기술로 악의적인 공격자로부터 시스템이나 애플리케이션을 보호하려는 목적이 있다.
- 인증 : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

## 나쁜 코드
#### 스파게티 코드
- 복잡성 : 
	- 복잡한 제어구조, 긴 함수
- 이해도 : 
	- 코드 흐름이 복잡하여 이해하기 어려움
- 유지보수성 : 
	- 수정과 확장이 어려움
- 협업 : 
	- 팀원 간 협업이 어려움
- 주요 문제 : 
	- 비일관적인 코드 흐름, 의존성 문제
#### 외계인 코드
- 복잡성 : 
	- 불명확한 변수명 및 함수명, 매직 넘버 사용
- 이해도 : 
	- 의미 불명확, 주석 부족으로 이해하기 어려움
- 유지보수성 : 
	- 의도 파악이 어려워 유지 보수가 힘듬
- 협업 : 
	- 팀원 간 협업이 어려움
- 주요 문제 : 
	- 코드 이해 어려움, 생산성 저하

## EAI
- Point-to-Point : 
	- 중간에 미들웨어를 두지 않고 각 애플리케이션 간 Point to Point 형태로 연결
- Hub&Spoke : 
	- 단일 접점이 허브 시스템을 통해 데이터를 전송하는 중앙 집중적 방식
- Message Bus : 
	- 애플리케이션 사이 미들웨어(버스)를 두어 처리
	- 미들웨어 통한 통합
- Hybrid : 
	- 그룹 내에는 Hub&Spoke 방식, 그룹 간에서는 메시징 버스 방식을 사용.

